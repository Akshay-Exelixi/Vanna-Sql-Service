"""
SQL Security Validator for role-based access control and injection detection.

This module provides comprehensive SQL validation including:
- Role-based query validation (employee/manager/hr/admin access levels)
- SQL injection detection and prevention
- Placeholder replacement for user context variables
- User filter enforcement for restricted roles
"""

import re
import logging
from typing import Dict, Any, Optional, List, Tuple
from dataclasses import dataclass, field
from enum import IntEnum

logger = logging.getLogger(__name__)


class RoleLevel(IntEnum):
    """Role levels for access control (higher = more access)
    
    Based on HRMS database roles table:
    - employee: level 1
    - department_manager: level 2
    - admin: level 3
    - super_admin: level 4
    """
    EMPLOYEE = 1
    DEPARTMENT_MANAGER = 2
    ADMIN = 3
    SUPER_ADMIN = 4


# Mapping from role names to levels
ROLE_LEVEL_MAP: Dict[str, int] = {
    "employee": RoleLevel.EMPLOYEE,
    "department_manager": RoleLevel.DEPARTMENT_MANAGER,
    "admin": RoleLevel.ADMIN,
    "super_admin": RoleLevel.SUPER_ADMIN,
}


@dataclass
class ValidationResult:
    """Result of SQL validation"""
    is_valid: bool
    sql: str  # Potentially modified SQL with placeholders replaced
    role_level: int
    warnings: List[str] = field(default_factory=list)
    errors: List[str] = field(default_factory=list)
    modifications: List[str] = field(default_factory=list)


class SQLSecurityValidator:
    """
    Validates and secures SQL queries based on user role and context.
    
    Features:
    - Role-based access control (RBAC)
    - SQL injection detection
    - User context placeholder replacement
    - Query scope enforcement
    """
    
    # SQL injection patterns to detect
    # Note: SQL comments (-- and /* */) are allowed since the SQL is generated by our LLM,
    # not from direct user input. The LLM often includes helpful comments.
    INJECTION_PATTERNS: List[Tuple[str, str]] = [
        # UNION-based injection (suspicious UNION targeting system tables)
        (r'\bUNION\s+(ALL\s+)?SELECT\b.*\bFROM\b.*\b(information_schema|pg_catalog|sys\.)\b',
         "Potential UNION injection targeting system tables"),
        
        # Hex/char encoding attacks
        (r'(0x[0-9a-fA-F]+|CHAR\s*\(\s*\d+\s*\))',
         "Hex or CHAR encoding detected"),
        
        # Sleep/benchmark attacks (DoS)
        (r'\b(SLEEP|BENCHMARK|WAITFOR|PG_SLEEP)\s*\(',
         "Time-based attack function detected"),
        
        # System command execution
        (r'\b(xp_cmdshell|LOAD_FILE|INTO\s+OUTFILE|INTO\s+DUMPFILE)\b',
         "System command or file operation detected"),
        
        # Always-true conditions in WHERE (auth bypass)
        (r"WHERE\s+.*\b(1\s*=\s*1|'.*'\s*=\s*'.*'|OR\s+1\s*=\s*1)\b",
         "Potential always-true condition for auth bypass"),
    ]
    
    # Dangerous operations that require elevated privileges
    DANGEROUS_OPERATIONS = ['DROP', 'TRUNCATE', 'ALTER', 'CREATE', 'GRANT', 'REVOKE']
    
    # Tables that contain sensitive data
    SENSITIVE_TABLES = ['employees', 'payroll', 'performance_reviews', 'salaries']
    
    def __init__(self, settings: Optional[Any] = None):
        """
        Initialize the validator.
        
        Args:
            settings: Application settings for allowed operations
        """
        self.allowed_operations = settings.ALLOWED_OPERATIONS if settings else [
            "SELECT", "INSERT", "UPDATE", "DELETE"
        ]
    
    def get_role_level(self, role_name: Optional[str]) -> int:
        """
        Convert role name to numeric level.
        
        Args:
            role_name: Role name string (e.g., 'employee', 'manager')
            
        Returns:
            Numeric role level (default: EMPLOYEE level if unknown)
        """
        if not role_name:
            return RoleLevel.EMPLOYEE
        return ROLE_LEVEL_MAP.get(role_name.lower(), RoleLevel.EMPLOYEE)
    
    def validate(
        self,
        sql: str,
        user_id: Optional[str],
        role: Optional[str],
        user_metadata: Optional[Dict[str, Any]] = None
    ) -> ValidationResult:
        """
        Perform comprehensive SQL validation.
        
        Args:
            sql: The SQL query to validate
            user_id: User ID for placeholder replacement
            role: User's role name
            user_metadata: Additional user context (team_member_ids, department_member_ids, etc.)
            
        Returns:
            ValidationResult with validation status and modified SQL
        """
        role_level = self.get_role_level(role)
        warnings: List[str] = []
        errors: List[str] = []
        modifications: List[str] = []
        modified_sql = sql
        
        logger.info(f"Validating SQL for user_id={user_id}, role={role} (level={role_level})")
        
        # 1. Check for SQL injection patterns
        injection_errors = self._detect_injection(sql)
        if injection_errors:
            errors.extend(injection_errors)
            return ValidationResult(
                is_valid=False,
                sql=sql,
                role_level=role_level,
                warnings=warnings,
                errors=errors,
                modifications=modifications
            )
        
        # 2. Replace placeholders with actual values
        modified_sql, placeholder_mods = self._replace_placeholders(
            modified_sql, user_id, user_metadata
        )
        modifications.extend(placeholder_mods)
        
        # 3. Validate operation type is allowed
        operation_error = self._validate_operation_type(sql)
        if operation_error:
            errors.append(operation_error)
        
        # 4. Check role-based access rules
        role_warnings, role_errors = self._validate_role_access(
            modified_sql, role_level, user_id, user_metadata
        )
        warnings.extend(role_warnings)
        errors.extend(role_errors)
        
        # 5. Enforce user filter for restricted roles (employees only)
        if role_level <= RoleLevel.EMPLOYEE:
            filter_result = self._enforce_user_filter(modified_sql, user_id, role_level)
            if filter_result.get('modified'):
                modified_sql = filter_result['sql']
                modifications.append(filter_result['modification'])
            if filter_result.get('warning'):
                warnings.append(filter_result['warning'])
            if filter_result.get('error'):
                errors.append(filter_result['error'])
        
        is_valid = len(errors) == 0
        
        if not is_valid:
            logger.warning(f"SQL validation failed: {errors}")
        elif warnings:
            logger.info(f"SQL validation passed with warnings: {warnings}")
        else:
            logger.info("SQL validation passed")
        
        return ValidationResult(
            is_valid=is_valid,
            sql=modified_sql,
            role_level=role_level,
            warnings=warnings,
            errors=errors,
            modifications=modifications
        )
    
    def _detect_injection(self, sql: str) -> List[str]:
        """
        Detect potential SQL injection patterns.
        
        Args:
            sql: SQL query to check
            
        Returns:
            List of injection warnings/errors
        """
        errors = []
        sql_upper = sql.upper()
        
        for pattern, message in self.INJECTION_PATTERNS:
            if re.search(pattern, sql, re.IGNORECASE):
                errors.append(f"Security violation: {message}")
                logger.warning(f"SQL injection pattern detected: {message}")
        
        # Note: Multiple statements are now allowed and handled by vanna_service
        # Each statement is validated individually for operation type
        
        return errors
    
    def _replace_placeholders(
        self,
        sql: str,
        user_id: Optional[str],
        user_metadata: Optional[Dict[str, Any]]
    ) -> Tuple[str, List[str]]:
        """
        Replace user context placeholders with actual values.
        
        Placeholders supported:
        - $CURRENT_USER_ID or {CURRENT_USER_ID} -> user's UUID
        - $TEAM_MEMBER_IDS -> comma-separated team member UUIDs
        - $DEPARTMENT_MEMBER_IDS -> comma-separated department member UUIDs
        
        Args:
            sql: SQL with placeholders
            user_id: User's UUID
            user_metadata: Dict with team_member_ids, department_member_ids, etc.
            
        Returns:
            Tuple of (modified_sql, list of modifications made)
        """
        modifications = []
        metadata = user_metadata or {}
        
        # Replace $CURRENT_USER_ID or {CURRENT_USER_ID}
        if user_id:
            patterns = [
                r'\$CURRENT_USER_ID',
                r'\{CURRENT_USER_ID\}',
                r'\$current_user_id',
                r'\{current_user_id\}'
            ]
            for pattern in patterns:
                if re.search(pattern, sql):
                    # Use quoted UUID for SQL safety
                    sql = re.sub(pattern, f"'{user_id}'", sql)
                    modifications.append(f"Replaced user ID placeholder with '{user_id}'")
        
        # Replace $TEAM_MEMBER_IDS
        team_ids = metadata.get('team_member_ids', [])
        if team_ids:
            team_ids_str = ", ".join([f"'{id}'" for id in team_ids])
            patterns = [r'\$TEAM_MEMBER_IDS', r'\{TEAM_MEMBER_IDS\}']
            for pattern in patterns:
                if re.search(pattern, sql, re.IGNORECASE):
                    sql = re.sub(pattern, team_ids_str, sql, flags=re.IGNORECASE)
                    modifications.append(f"Replaced team member IDs placeholder with {len(team_ids)} IDs")
        
        # Replace $DEPARTMENT_MEMBER_IDS
        dept_ids = metadata.get('department_member_ids', [])
        if dept_ids:
            dept_ids_str = ", ".join([f"'{id}'" for id in dept_ids])
            patterns = [r'\$DEPARTMENT_MEMBER_IDS', r'\{DEPARTMENT_MEMBER_IDS\}']
            for pattern in patterns:
                if re.search(pattern, sql, re.IGNORECASE):
                    sql = re.sub(pattern, dept_ids_str, sql, flags=re.IGNORECASE)
                    modifications.append(f"Replaced department member IDs placeholder with {len(dept_ids)} IDs")
        
        # Replace $MANAGER_ID if present
        manager_id = metadata.get('manager_id')
        if manager_id:
            patterns = [r'\$MANAGER_ID', r'\{MANAGER_ID\}']
            for pattern in patterns:
                if re.search(pattern, sql, re.IGNORECASE):
                    sql = re.sub(pattern, f"'{manager_id}'", sql, flags=re.IGNORECASE)
                    modifications.append(f"Replaced manager ID placeholder with '{manager_id}'")
        
        # Replace $DEPARTMENT_ID if present
        dept_id = metadata.get('department_id')
        if dept_id:
            patterns = [r'\$DEPARTMENT_ID', r'\{DEPARTMENT_ID\}']
            for pattern in patterns:
                if re.search(pattern, sql, re.IGNORECASE):
                    sql = re.sub(pattern, f"'{dept_id}'", sql, flags=re.IGNORECASE)
                    modifications.append(f"Replaced department ID placeholder with '{dept_id}'")
        
        return sql, modifications
    
    def _strip_sql_comments(self, sql: str) -> str:
        """
        Strip SQL comments from the beginning of SQL statements.
        Handles both single-line (--) and multi-line (/* */) comments.
        """
        sql = sql.strip()
        
        while sql:
            # Skip single-line comments
            if sql.startswith('--'):
                newline_idx = sql.find('\n')
                if newline_idx == -1:
                    return ''  # Entire SQL is a comment
                sql = sql[newline_idx + 1:].strip()
            # Skip multi-line comments
            elif sql.startswith('/*'):
                end_idx = sql.find('*/')
                if end_idx == -1:
                    return ''  # Unclosed comment
                sql = sql[end_idx + 2:].strip()
            else:
                break
        
        return sql
    
    def _validate_operation_type(self, sql: str) -> Optional[str]:
        """
        Validate that the SQL operation type is allowed.
        
        Args:
            sql: SQL query
            
        Returns:
            Error message if operation not allowed, None otherwise
        """
        # Strip leading comments before checking operation type
        sql_stripped = self._strip_sql_comments(sql)
        sql_upper = sql_stripped.upper()
        
        # Check for dangerous operations first
        for op in self.DANGEROUS_OPERATIONS:
            if re.match(rf'^\s*{op}\b', sql_upper):
                return f"Operation '{op}' is not allowed for security reasons"
        
        # Check if operation is in allowed list
        for op in ['SELECT', 'INSERT', 'UPDATE', 'DELETE', 'WITH']:
            if sql_upper.startswith(op):
                if op == 'WITH':  # CTE is allowed (treated as SELECT)
                    return None
                if op not in self.allowed_operations:
                    return f"Operation '{op}' is not allowed by configuration"
                return None
        
        return "Unknown or unsupported SQL operation type"
    
    def _validate_role_access(
        self,
        sql: str,
        role_level: int,
        user_id: Optional[str],
        user_metadata: Optional[Dict[str, Any]]
    ) -> Tuple[List[str], List[str]]:
        """
        Validate query against role-based access rules.
        
        Rules based on HRMS database role levels:
        - Level 5 (Employee): Must have employee_id filter for personal data tables
        - Level 8 (Department Manager): Can query team data, full access to managed employees
        - Level 9-10 (Admin/Super Admin): Full access
        
        Args:
            sql: SQL query
            role_level: Numeric role level from database
            user_id: User's ID
            user_metadata: Additional context
            
        Returns:
            Tuple of (warnings, errors)
        """
        warnings = []
        errors = []
        sql_upper = sql.upper()
        
        # Check for sensitive table access
        for table in self.SENSITIVE_TABLES:
            if re.search(rf'\b{table.upper()}\b', sql_upper):
                if role_level < RoleLevel.DEPARTMENT_MANAGER:
                    # Employees accessing sensitive tables need employee_id filter
                    if user_id and not self._has_user_filter(sql, user_id):
                        errors.append(
                            f"Access denied: Role level {role_level} cannot query '{table}' "
                            f"without employee_id filter"
                        )
                elif role_level < RoleLevel.ADMIN:
                    # Managers can only see their team
                    if 'payroll' in table.lower() or 'salaries' in table.lower():
                        warnings.append(
                            f"Warning: Manager-level access to '{table}' - "
                            f"ensure query is scoped to your team"
                        )
        
        # Check for SELECT * without WHERE on large tables
        if re.search(r'SELECT\s+\*\s+FROM', sql_upper) and 'WHERE' not in sql_upper:
            if role_level < RoleLevel.ADMIN:
                warnings.append(
                    "Warning: Unfiltered SELECT * query - consider adding filters"
                )
        
        # Employees cannot UPDATE/DELETE without employee_id filter
        if role_level <= RoleLevel.EMPLOYEE:
            if re.match(r'^\s*(UPDATE|DELETE)\b', sql_upper):
                if user_id and not self._has_user_filter(sql, user_id):
                    errors.append(
                        f"Access denied: {self._get_operation_type(sql)} operations require "
                        f"employee_id filter for role level {role_level}"
                    )
        
        return warnings, errors
    
    def _has_user_filter(self, sql: str, user_id: str) -> bool:
        """
        Check if SQL has a filter for the specific user.
        
        Args:
            sql: SQL query
            user_id: User's UUID
            
        Returns:
            True if user filter exists
        """
        sql_lower = sql.lower()
        
        # Check for direct user_id filter
        patterns = [
            rf"employee_id\s*=\s*'{re.escape(user_id)}'",
            rf"employee_id\s*=\s*'{re.escape(user_id)}'::uuid",
            rf"user_id\s*=\s*'{re.escape(user_id)}'",
            rf"created_by\s*=\s*'{re.escape(user_id)}'",
            rf"requested_by\s*=\s*'{re.escape(user_id)}'",
        ]
        
        for pattern in patterns:
            if re.search(pattern, sql_lower):
                return True
        
        return False
    
    def _enforce_user_filter(
        self,
        sql: str,
        user_id: Optional[str],
        role_level: int
    ) -> Dict[str, Any]:
        """
        Enforce user filter for restricted roles (adds filter if missing).
        
        Note: This is a safety net. Ideally, the LLM should generate proper filters.
        
        Args:
            sql: SQL query
            user_id: User's UUID
            role_level: User's role level
            
        Returns:
            Dict with 'sql', 'modified', 'modification', 'warning', 'error'
        """
        result = {
            'sql': sql,
            'modified': False,
            'modification': None,
            'warning': None,
            'error': None
        }
        
        if not user_id:
            result['error'] = "User ID required for role-based filtering"
            return result
        
        # Only enforce for employee-level roles (level 5 or below)
        if role_level > RoleLevel.EMPLOYEE:
            return result
        
        # Check if already has user filter
        if self._has_user_filter(sql, user_id):
            return result
        
        # For SELECT queries without user filter, add a warning but don't modify
        # (modifying could break complex queries)
        sql_upper = sql.strip().upper()
        if sql_upper.startswith('SELECT'):
            # Check if query targets user-specific tables
            user_tables = ['tr_leaves', 'tr_attendance', 'tr_expenses', 'performance_reviews']
            for table in user_tables:
                if re.search(rf'\b{table}\b', sql, re.IGNORECASE):
                    result['warning'] = (
                        f"Query on '{table}' without employee_id filter. "
                        f"Results may include data from other users."
                    )
                    break
        
        return result
    
    def _get_operation_type(self, sql: str) -> str:
        """Extract operation type from SQL."""
        sql_upper = sql.strip().upper()
        for op in ['SELECT', 'INSERT', 'UPDATE', 'DELETE', 'WITH']:
            if sql_upper.startswith(op):
                return op
        return 'UNKNOWN'


# Convenience function for quick validation
def validate_sql(
    sql: str,
    user_id: Optional[str] = None,
    role: Optional[str] = None,
    user_metadata: Optional[Dict[str, Any]] = None,
    settings: Optional[Any] = None
) -> ValidationResult:
    """
    Quick validation function.
    
    Args:
        sql: SQL query to validate
        user_id: User's UUID
        role: User's role name
        user_metadata: Additional user context
        settings: Application settings
        
    Returns:
        ValidationResult
    """
    validator = SQLSecurityValidator(settings)
    return validator.validate(sql, user_id, role, user_metadata)
