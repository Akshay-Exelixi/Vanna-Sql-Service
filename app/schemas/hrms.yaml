# HRMS Schema Training Configuration
# This file defines the database schema and example queries for Vanna AI training
# Version: 1.2.0 - Added Document Management

schema:
  name: hrms
  version: "1.2.0"
  description: "Human Resource Management System database schema for leave, asset, and document management"
  database_schema: public

tables:
  # Transaction table for leave requests (NOTE: prefix 'tr_' indicates transaction table)
  - name: tr_leaves
    description: "Leave requests and approvals - main transaction table for leave management"
    discovery: true  # Auto-discover DDL from database
    notes: |
      IMPORTANT: Leave requests are stored in 'tr_leaves' table (NOT 'leaves')
      - Status values: 'pending', 'approved', 'rejected', 'cancelled'
      - Always calculate 'days' as (end_date - start_date + 1) for leave duration
      - Use RETURNING * for INSERT/UPDATE operations to get the affected rows
    columns:
      id:
        description: "Auto-increment primary key"
        type: serial
      employee_id:
        description: "Employee requesting leave"
        type: uuid
        is_foreign_key: true
        references: employees.id
      start_date:
        description: "Leave start date"
        type: date
      end_date:
        description: "Leave end date"
        type: date
      days:
        description: "Number of leave days (calculated as end_date - start_date + 1)"
        type: integer
      status:
        description: "Current approval status"
        type: varchar
        allowed_values: [pending, approved, rejected, cancelled]
      leave_type_id:
        description: "Type of leave (sick, vacation, etc.)"
        type: integer
        is_foreign_key: true
        references: leave_types.id
      approved_by:
        description: "Manager who approved/rejected the leave"
        type: uuid
        is_foreign_key: true
        references: employees.id
      reason:
        description: "Reason for leave request"
        type: text
      file_path:
        description: "Path to supporting documents (medical certificate, etc.)"
        type: varchar

  # Employee master data
  - name: employees
    description: "Employee master data - contains all employee information"
    discovery: true
    notes: |
      - Employee IDs are UUID type, use ::uuid cast when inserting/querying
      - Status: 'active' or 'inactive'
      - Always filter by status = 'active' for current employees
    columns:
      id:
        description: "UUID primary key"
        type: uuid
      first_name:
        description: "Employee first name"
        type: varchar
      last_name:
        description: "Employee last name"
        type: varchar
      email:
        description: "Employee email address (unique)"
        type: varchar
      position:
        description: "Job title/position"
        type: varchar
      status:
        description: "Employment status"
        type: varchar
        allowed_values: [active, inactive]
      department_id:
        description: "Department the employee belongs to"
        type: integer
        is_foreign_key: true
        references: departments.id
      role_id:
        description: "Role assigned to employee"
        type: integer
        is_foreign_key: true
        references: roles.id
      manager_id:
        description: "Direct manager (self-referencing)"
        type: uuid
        is_foreign_key: true
        references: employees.id
      hire_date:
        description: "Date when employee was hired"
        type: date
      salary:
        description: "Employee salary"
        type: decimal

  # Role definitions
  - name: roles
    description: "Role definitions with access levels"
    discovery: true
    notes: |
      - Role level determines permissions (higher = more access)
      - Levels: 0=basic, 1=staff, 2=supervisor, 3=manager, 4=hr, 5=admin
    columns:
      id:
        description: "Auto-increment primary key"
        type: serial
      name:
        description: "Role name (e.g., Employee, Manager, HR Admin)"
        type: varchar
      level:
        description: "Access level (0-5)"
        type: integer
      description:
        description: "Role description"
        type: text

  # Leave type configuration
  - name: leave_types
    description: "Leave type configuration - defines types of leaves and their policies"
    discovery: true
    notes: |
      - days_allowed: Annual quota for this leave type
      - requires_approval: Whether manager approval is needed
    columns:
      id:
        description: "Auto-increment primary key"
        type: serial
      name:
        description: "Leave type name (e.g., Sick Leave, Annual Leave)"
        type: varchar
      days_allowed:
        description: "Maximum days allowed per year"
        type: integer
      requires_approval:
        description: "Whether this leave type requires approval"
        type: boolean
      description:
        description: "Leave type description"
        type: text

  # Department structure
  - name: departments
    description: "Organization department structure"
    discovery: true
    columns:
      id:
        description: "Auto-increment primary key"
        type: serial
      name:
        description: "Department name"
        type: varchar
      description:
        description: "Department description"
        type: text

  # Permission definitions
  - name: permissions
    description: "Permission definitions for role-based access control"
    discovery: true
    notes: |
      - Defines granular permissions that can be assigned to roles
      - resource: The resource being accessed (e.g., 'leaves', 'employees')
      - action: The action being performed (e.g., 'read', 'create', 'update', 'delete', 'approve')
    columns:
      id:
        description: "UUID primary key"
        type: uuid
      name:
        description: "Permission name (e.g., 'view_own_leaves', 'approve_leaves')"
        type: varchar
      description:
        description: "Permission description"
        type: text
      resource:
        description: "Resource this permission applies to"
        type: varchar
      action:
        description: "Action this permission allows"
        type: varchar
      created_at:
        description: "When permission was created"
        type: timestamp
      updated_at:
        description: "When permission was last updated"
        type: timestamp

  # Role-Permission mapping
  - name: tr_role_permissions
    description: "Junction table mapping roles to permissions"
    discovery: true
    notes: |
      - Many-to-many relationship between roles and permissions
      - Defines which permissions each role has
      - Use this to check if a role has a specific permission
    columns:
      role_id:
        description: "Role UUID"
        type: uuid
        is_foreign_key: true
        references: roles.id
      permission_id:
        description: "Permission UUID"
        type: uuid
        is_foreign_key: true
        references: permissions.id
      created_at:
        description: "When this permission was granted to the role"
        type: timestamp

  # Asset type configuration
  - name: asset_types
    description: "Asset type configuration - defines categories of company assets"
    discovery: true
    notes: |
      - Defines asset categories like IT Equipment, Travel Assets, Office Supplies
      - Used to categorize assets in tr_assets table
    columns:
      id:
        description: "UUID primary key"
        type: uuid
      name:
        description: "Asset type name (e.g., IT Equipment, Office Supplies)"
        type: varchar
      description:
        description: "Description of what assets belong to this type"
        type: text
      created_at:
        description: "When the asset type was created"
        type: timestamp
      updated_at:
        description: "When the asset type was last updated"
        type: timestamp

  # Transaction table for assets (NOTE: prefix 'tr_' indicates transaction table)
  - name: tr_assets
    description: "Asset tracking and assignments - main transaction table for asset management"
    discovery: true
    notes: |
      IMPORTANT: Asset records are stored in 'tr_assets' table (NOT 'assets')
      - Status values: 'pending', 'approved', 'rejected', 'Available'
      - assigned_to links to employees table (NULL means unassigned)
      - Use RETURNING * for INSERT/UPDATE operations to get the affected rows
    columns:
      id:
        description: "UUID primary key"
        type: uuid
      name:
        description: "Asset name/description"
        type: varchar
      serial_number:
        description: "Asset serial number or identifier"
        type: varchar
      purchase_date:
        description: "Date asset was purchased"
        type: date
      purchase_cost:
        description: "Cost of the asset in decimal format"
        type: decimal
      assigned_to:
        description: "Employee who has the asset assigned (NULL if unassigned)"
        type: uuid
        is_foreign_key: true
        references: employees.id
      status:
        description: "Current asset status"
        type: varchar
        allowed_values: [pending, approved, rejected, Available]
      notes:
        description: "Additional notes about the asset"
        type: text
      asset_type_id:
        description: "Type/category of the asset"
        type: uuid
        is_foreign_key: true
        references: asset_types.id
      created_at:
        description: "When the asset record was created"
        type: timestamp
      updated_at:
        description: "When the asset record was last updated"
        type: timestamp

  # Document type configuration
  - name: document_types
    description: "Document type configuration - defines categories of employee documents"
    discovery: true
    notes: |
      - Defines document categories like Passport, Visa, ID Card, Contract, etc.
      - Used to categorize documents in tr_documents table
    columns:
      id:
        description: "UUID primary key"
        type: uuid
      name:
        description: "Document type name (e.g., Passport, Visa, Employment Contract)"
        type: varchar
      description:
        description: "Description of what documents belong to this type"
        type: text
      created_at:
        description: "When the document type was created"
        type: timestamp
      updated_at:
        description: "When the document type was last updated"
        type: timestamp

  # Transaction table for documents (NOTE: prefix 'tr_' indicates transaction table)
  - name: tr_documents
    description: "Employee document management - main transaction table for document tracking"
    discovery: true
    notes: |
      IMPORTANT: Document records are stored in 'tr_documents' table (NOT 'documents')
      - Status values: 'pending', 'approved', 'rejected'
      - employee_id links to employees table
      - expiry_date for documents with validity period (passport, visa, etc.)
      - notification_days_before: Days before expiry to send notification
      - Use RETURNING * for INSERT/UPDATE operations to get the affected rows
    columns:
      id:
        description: "UUID primary key"
        type: uuid
      employee_id:
        description: "Employee who owns the document"
        type: uuid
        is_foreign_key: true
        references: employees.id
      name:
        description: "Document name/title"
        type: varchar
      file_path:
        description: "Path to the uploaded document file"
        type: varchar
      description:
        description: "Document description or notes"
        type: text
      upload_date:
        description: "When the document was uploaded"
        type: timestamp
      expiry_date:
        description: "Document expiry date (for passports, visas, etc.)"
        type: date
      type_id:
        description: "Type/category of the document"
        type: uuid
        is_foreign_key: true
        references: document_types.id
      notification_days_before:
        description: "Days before expiry to send notification (default 30)"
        type: integer
      notifications_enabled:
        description: "Whether expiry notifications are enabled"
        type: boolean
      status:
        description: "Document approval status"
        type: varchar
        allowed_values: [pending, approved, rejected]
      approved_by:
        description: "Employee who approved the document"
        type: uuid
        is_foreign_key: true
        references: employees.id
      approved_at:
        description: "When the document was approved"
        type: timestamp
      rejected_by:
        description: "Employee who rejected the document"
        type: uuid
        is_foreign_key: true
        references: employees.id
      rejected_at:
        description: "When the document was rejected"
        type: timestamp
      rejection_reason:
        description: "Reason for document rejection"
        type: text
      notes:
        description: "Additional notes about the document"
        type: text
      additional_data:
        description: "JSONB field for extra document metadata"
        type: jsonb
      created_at:
        description: "When the document record was created"
        type: timestamp
      updated_at:
        description: "When the document record was last updated"
        type: timestamp

examples:
  # Leave counting and status queries
  - question: "How many pending leaves are there?"
    sql: "SELECT COUNT(*) as pending_count FROM tr_leaves WHERE status = 'pending';"
    category: leaves
    description: "Count pending leave requests"

  - question: "How many leaves were approved this month?"
    sql: |
      SELECT COUNT(*) as approved_count 
      FROM tr_leaves 
      WHERE status = 'approved' 
      AND EXTRACT(MONTH FROM start_date) = EXTRACT(MONTH FROM CURRENT_DATE)
      AND EXTRACT(YEAR FROM start_date) = EXTRACT(YEAR FROM CURRENT_DATE);
    category: analytics

  - question: "Count leaves by status"
    sql: "SELECT status, COUNT(*) as count FROM tr_leaves GROUP BY status ORDER BY count DESC;"
    category: analytics

  # Leave listing queries
  - question: "Show all pending leave requests"
    sql: |
      SELECT l.id, e.first_name, e.last_name, lt.name as leave_type, 
             l.start_date, l.end_date, l.days, l.status, l.reason
      FROM tr_leaves l
      JOIN employees e ON l.employee_id = e.id
      LEFT JOIN leave_types lt ON l.leave_type_id = lt.id
      WHERE l.status = 'pending'
      ORDER BY l.created_at DESC;
    category: leaves
    description: "List all pending leave requests with employee details"

  - question: "Show approved leaves this month"
    sql: |
      SELECT l.id, e.first_name, e.last_name, lt.name as leave_type,
             l.start_date, l.end_date, l.days
      FROM tr_leaves l
      JOIN employees e ON l.employee_id = e.id
      LEFT JOIN leave_types lt ON l.leave_type_id = lt.id
      WHERE l.status = 'approved'
      AND EXTRACT(MONTH FROM l.start_date) = EXTRACT(MONTH FROM CURRENT_DATE)
      ORDER BY l.start_date;
    category: leaves

  - question: "Show leaves for a specific employee"
    sql: |
      SELECT l.id, lt.name as leave_type, l.start_date, l.end_date, 
             l.days, l.status, l.reason
      FROM tr_leaves l
      LEFT JOIN leave_types lt ON l.leave_type_id = lt.id
      WHERE l.employee_id = $1::uuid
      ORDER BY l.start_date DESC;
    category: leaves
    description: "Get all leaves for a specific employee by ID"

  # Leave balance queries
  - question: "Get leave balance for an employee"
    sql: |
      SELECT 
        lt.name as leave_type,
        lt.days_allowed,
        COALESCE(SUM(l.days), 0) as days_taken,
        lt.days_allowed - COALESCE(SUM(l.days), 0) as balance
      FROM leave_types lt
      LEFT JOIN tr_leaves l ON lt.id = l.leave_type_id 
        AND l.employee_id = $1::uuid 
        AND l.status = 'approved'
        AND EXTRACT(YEAR FROM l.start_date) = EXTRACT(YEAR FROM CURRENT_DATE)
      GROUP BY lt.id, lt.name, lt.days_allowed;
    category: leaves
    description: "Calculate remaining leave balance per leave type"

  # Insert/Update operations
  - question: "Insert a new leave request"
    sql: |
      INSERT INTO tr_leaves (employee_id, start_date, end_date, days, status, leave_type_id, reason)
      VALUES ($1::uuid, $2::date, $3::date, ($3::date - $2::date + 1), 'pending', $4, $5)
      RETURNING *;
    category: write
    description: "Create new leave request - days auto-calculated"

  - question: "Approve a leave request"
    sql: |
      UPDATE tr_leaves 
      SET status = 'approved', approved_by = $2::uuid, updated_at = CURRENT_TIMESTAMP 
      WHERE id = $1 AND status = 'pending'
      RETURNING *;
    category: write
    description: "Approve a pending leave request"

  - question: "Reject a leave request"
    sql: |
      UPDATE tr_leaves 
      SET status = 'rejected', approved_by = $2::uuid, updated_at = CURRENT_TIMESTAMP 
      WHERE id = $1 AND status = 'pending'
      RETURNING *;
    category: write

  # Employee queries
  - question: "Get all employees with their roles and departments"
    sql: |
      SELECT e.id, e.first_name, e.last_name, e.email, e.position,
        r.name as role_name, d.name as department_name
      FROM employees e
      LEFT JOIN roles r ON e.role_id = r.id
      LEFT JOIN departments d ON e.department_id = d.id
      WHERE e.status = 'active'
      ORDER BY e.first_name;
    category: employees

  - question: "Find employees by department"
    sql: |
      SELECT e.id, e.first_name, e.last_name, e.email, e.position
      FROM employees e
      JOIN departments d ON e.department_id = d.id
      WHERE d.name ILIKE $1
      AND e.status = 'active'
      ORDER BY e.first_name;
    category: employees

  - question: "Get employee count by department"
    sql: |
      SELECT d.name as department, COUNT(e.id) as employee_count
      FROM departments d
      LEFT JOIN employees e ON d.id = e.department_id AND e.status = 'active'
      GROUP BY d.id, d.name
      ORDER BY employee_count DESC;
    category: analytics

  # Leave analytics
  - question: "Get leave summary by department"
    sql: |
      SELECT d.name as department,
        COUNT(CASE WHEN l.status = 'pending' THEN 1 END) as pending,
        COUNT(CASE WHEN l.status = 'approved' THEN 1 END) as approved,
        COUNT(CASE WHEN l.status = 'rejected' THEN 1 END) as rejected
      FROM departments d
      LEFT JOIN employees e ON d.id = e.department_id
      LEFT JOIN tr_leaves l ON e.id = l.employee_id
      GROUP BY d.id, d.name
      ORDER BY d.name;
    category: analytics

  - question: "Get most common leave types"
    sql: |
      SELECT lt.name as leave_type, COUNT(l.id) as count
      FROM leave_types lt
      LEFT JOIN tr_leaves l ON lt.id = l.leave_type_id
      GROUP BY lt.id, lt.name
      ORDER BY count DESC;
    category: analytics

  # User-specific queries (use $CURRENT_USER_ID placeholder)
  - question: "Show my pending leave requests"
    sql: |
      SELECT l.id, lt.name as leave_type, l.start_date, l.end_date, 
             l.days, l.status, l.reason, l.created_at
      FROM tr_leaves l
      LEFT JOIN leave_types lt ON l.leave_type_id = lt.id
      WHERE l.employee_id = $CURRENT_USER_ID::uuid
      AND l.status = 'pending'
      ORDER BY l.created_at DESC;
    category: user_specific
    description: "Get current user's pending leave requests"

  - question: "Show all my leave requests"
    sql: |
      SELECT l.id, lt.name as leave_type, l.start_date, l.end_date, 
             l.days, l.status, l.reason, l.created_at
      FROM tr_leaves l
      LEFT JOIN leave_types lt ON l.leave_type_id = lt.id
      WHERE l.employee_id = $CURRENT_USER_ID::uuid
      ORDER BY l.created_at DESC;
    category: user_specific
    description: "Get all leave requests for current user"

  - question: "Show my approved leaves this year"
    sql: |
      SELECT l.id, lt.name as leave_type, l.start_date, l.end_date, l.days
      FROM tr_leaves l
      LEFT JOIN leave_types lt ON l.leave_type_id = lt.id
      WHERE l.employee_id = $CURRENT_USER_ID::uuid
      AND l.status = 'approved'
      AND EXTRACT(YEAR FROM l.start_date) = EXTRACT(YEAR FROM CURRENT_DATE)
      ORDER BY l.start_date DESC;
    category: user_specific

  - question: "How many pending leaves do I have?"
    sql: |
      SELECT COUNT(*) as my_pending_count 
      FROM tr_leaves 
      WHERE employee_id = $CURRENT_USER_ID::uuid 
      AND status = 'pending';
    category: user_specific

  # Manager-specific queries (use $TEAM_MEMBER_IDS placeholder)
  - question: "Show leave requests I need to approve"
    sql: |
      SELECT l.id, e.first_name, e.last_name, lt.name as leave_type,
             l.start_date, l.end_date, l.days, l.reason, l.created_at
      FROM tr_leaves l
      JOIN employees e ON l.employee_id = e.id
      LEFT JOIN leave_types lt ON l.leave_type_id = lt.id
      WHERE e.manager_id = $CURRENT_USER_ID::uuid
      AND l.status = 'pending'
      ORDER BY l.created_at DESC;
    category: manager
    description: "Get pending leave requests from direct reports"

  - question: "Show my team's pending leaves"
    sql: |
      SELECT l.id, e.first_name, e.last_name, lt.name as leave_type,
             l.start_date, l.end_date, l.days, l.status
      FROM tr_leaves l
      JOIN employees e ON l.employee_id = e.id
      LEFT JOIN leave_types lt ON l.leave_type_id = lt.id
      WHERE e.manager_id = $CURRENT_USER_ID::uuid
      AND l.status = 'pending'
      ORDER BY l.created_at DESC;
    category: manager

  - question: "Show all my team's leaves"
    sql: |
      SELECT l.id, e.first_name, e.last_name, lt.name as leave_type,
             l.start_date, l.end_date, l.days, l.status
      FROM tr_leaves l
      JOIN employees e ON l.employee_id = e.id
      LEFT JOIN leave_types lt ON l.leave_type_id = lt.id
      WHERE e.manager_id = $CURRENT_USER_ID::uuid
      ORDER BY l.created_at DESC;
    category: manager

  - question: "How many pending approvals do I have?"
    sql: |
      SELECT COUNT(*) as pending_approvals
      FROM tr_leaves l
      JOIN employees e ON l.employee_id = e.id
      WHERE e.manager_id = $CURRENT_USER_ID::uuid
      AND l.status = 'pending';
    category: manager

  - question: "Show leaves I have approved"
    sql: |
      SELECT l.id, e.first_name, e.last_name, lt.name as leave_type,
             l.start_date, l.end_date, l.days, l.created_at
      FROM tr_leaves l
      JOIN employees e ON l.employee_id = e.id
      LEFT JOIN leave_types lt ON l.leave_type_id = lt.id
      WHERE l.approved_by = $CURRENT_USER_ID::uuid
      AND l.status = 'approved'
      ORDER BY l.updated_at DESC;
    category: manager

  # Time-series and trend queries
  - question: "Show leave trend for the past 2 months"
    sql: |
      WITH days AS (
        SELECT d::date AS day
        FROM generate_series(
          (CURRENT_DATE - INTERVAL '2 months'),
          CURRENT_DATE,
          INTERVAL '1 day'
        ) AS d
      ),
      counts AS (
        SELECT start_date::date AS day, COUNT(*) AS leave_count
        FROM tr_leaves
        WHERE start_date >= (CURRENT_DATE - INTERVAL '2 months')
        GROUP BY start_date::date
      )
      SELECT d.day, COALESCE(c.leave_count, 0) AS leave_count
      FROM days d
      LEFT JOIN counts c USING (day)
      ORDER BY d.day;
    category: analytics
    description: "Daily leave count trend over past 2 months"

  - question: "Show monthly leave trends"
    sql: |
      SELECT 
        DATE_TRUNC('month', start_date) AS month,
        COUNT(*) AS total_leaves,
        COUNT(CASE WHEN status = 'approved' THEN 1 END) AS approved,
        COUNT(CASE WHEN status = 'pending' THEN 1 END) AS pending,
        COUNT(CASE WHEN status = 'rejected' THEN 1 END) AS rejected
      FROM tr_leaves
      WHERE start_date >= (CURRENT_DATE - INTERVAL '6 months')
      GROUP BY DATE_TRUNC('month', start_date)
      ORDER BY month DESC;
    category: analytics
    description: "Monthly leave statistics for past 6 months"

  - question: "Show weekly leave pattern"
    sql: |
      SELECT 
        EXTRACT(DOW FROM start_date) AS day_of_week,
        TO_CHAR(start_date, 'Day') AS day_name,
        COUNT(*) AS leave_count
      FROM tr_leaves
      WHERE start_date >= (CURRENT_DATE - INTERVAL '3 months')
      GROUP BY EXTRACT(DOW FROM start_date), TO_CHAR(start_date, 'Day')
      ORDER BY day_of_week;
    category: analytics
    description: "Leave frequency by day of week"

  - question: "Show leaves for last week"
    sql: |
      SELECT l.id, e.first_name, e.last_name, lt.name as leave_type,
             l.start_date, l.end_date, l.days, l.status
      FROM tr_leaves l
      JOIN employees e ON l.employee_id = e.id
      LEFT JOIN leave_types lt ON l.leave_type_id = lt.id
      WHERE l.start_date >= (CURRENT_DATE - INTERVAL '1 week')
      ORDER BY l.start_date DESC;
    category: leaves
    description: "All leaves starting in the past week"

  # Role and Permission queries
  - question: "Get all permissions for a role"
    sql: |
      SELECT p.name, p.description, p.resource, p.action
      FROM permissions p
      JOIN tr_role_permissions rp ON p.id = rp.permission_id
      WHERE rp.role_id = $1::uuid
      ORDER BY p.resource, p.action;
    category: roles
    description: "List all permissions assigned to a specific role"

  - question: "Check if a role has a specific permission"
    sql: |
      SELECT EXISTS (
        SELECT 1 FROM tr_role_permissions rp
        JOIN permissions p ON rp.permission_id = p.id
        WHERE rp.role_id = $1::uuid AND p.name = $2
      ) as has_permission;
    category: roles

  - question: "Get all roles with their permission counts"
    sql: |
      SELECT r.name as role_name, r.level, 
             COUNT(rp.permission_id) as permission_count
      FROM roles r
      LEFT JOIN tr_role_permissions rp ON r.id = rp.role_id
      GROUP BY r.id, r.name, r.level
      ORDER BY r.level DESC;
    category: analytics

  - question: "List all permissions by resource"
    sql: |
      SELECT resource, 
             COUNT(*) as permission_count,
             STRING_AGG(action, ', ') as actions
      FROM permissions
      GROUP BY resource
      ORDER BY resource;
    category: roles

  - question: "Get user's permissions through their role"
    sql: |
      SELECT DISTINCT p.name, p.description, p.resource, p.action
      FROM employees e
      JOIN roles r ON e.role_id = r.id
      JOIN tr_role_permissions rp ON r.id = rp.role_id
      JOIN permissions p ON rp.permission_id = p.id
      WHERE e.id = $1::uuid
      ORDER BY p.resource, p.action;
    category: roles
    description: "Get all permissions for a specific employee via their role"

  # Asset counting and status queries
  - question: "How many pending assets are there?"
    sql: "SELECT COUNT(*) as pending_count FROM tr_assets WHERE status = 'pending';"
    category: assets
    description: "Count pending asset requests"

  - question: "How many assets were approved this month?"
    sql: |
      SELECT COUNT(*) as approved_count 
      FROM tr_assets 
      WHERE status = 'approved' 
      AND EXTRACT(MONTH FROM created_at) = EXTRACT(MONTH FROM CURRENT_DATE)
      AND EXTRACT(YEAR FROM created_at) = EXTRACT(YEAR FROM CURRENT_DATE);
    category: analytics

  - question: "Count assets by status"
    sql: "SELECT status, COUNT(*) as count FROM tr_assets GROUP BY status ORDER BY count DESC;"
    category: analytics

  - question: "Count assets by type"
    sql: |
      SELECT at.name as asset_type, COUNT(a.id) as count
      FROM asset_types at
      LEFT JOIN tr_assets a ON at.id = a.asset_type_id
      GROUP BY at.id, at.name
      ORDER BY count DESC;
    category: analytics

  # Asset listing queries
  - question: "Show all pending asset requests"
    sql: |
      SELECT a.id, e.first_name, e.last_name, at.name as asset_type, 
             a.name, a.serial_number, a.status, a.notes
      FROM tr_assets a
      LEFT JOIN employees e ON a.assigned_to = e.id
      LEFT JOIN asset_types at ON a.asset_type_id = at.id
      WHERE a.status = 'pending'
      ORDER BY a.created_at DESC;
    category: assets
    description: "List all pending asset requests with employee details"

  - question: "Show approved assets this month"
    sql: |
      SELECT a.id, e.first_name, e.last_name, at.name as asset_type,
             a.name, a.serial_number, a.purchase_cost
      FROM tr_assets a
      LEFT JOIN employees e ON a.assigned_to = e.id
      LEFT JOIN asset_types at ON a.asset_type_id = at.id
      WHERE a.status = 'approved'
      AND EXTRACT(MONTH FROM a.updated_at) = EXTRACT(MONTH FROM CURRENT_DATE)
      ORDER BY a.updated_at DESC;
    category: assets

  - question: "Show assets for a specific employee"
    sql: |
      SELECT a.id, at.name as asset_type, a.name, a.serial_number,
             a.purchase_date, a.purchase_cost, a.status, a.notes
      FROM tr_assets a
      LEFT JOIN asset_types at ON a.asset_type_id = at.id
      WHERE a.assigned_to = $1::uuid
      ORDER BY a.created_at DESC;
    category: assets
    description: "Get all assets assigned to a specific employee by ID"

  - question: "Show all available assets"
    sql: |
      SELECT a.id, at.name as asset_type, a.name, a.serial_number,
             a.purchase_date, a.purchase_cost
      FROM tr_assets a
      LEFT JOIN asset_types at ON a.asset_type_id = at.id
      WHERE a.assigned_to IS NULL AND a.status = 'approved'
      ORDER BY at.name, a.name;
    category: assets
    description: "List all unassigned/available assets"

  # Asset value analytics
  - question: "Get total asset value by type"
    sql: |
      SELECT at.name as asset_type,
        COUNT(a.id) as asset_count,
        SUM(a.purchase_cost) as total_value,
        AVG(a.purchase_cost) as avg_value
      FROM asset_types at
      LEFT JOIN tr_assets a ON at.id = a.asset_type_id AND a.status = 'approved'
      GROUP BY at.id, at.name
      ORDER BY total_value DESC NULLS LAST;
    category: analytics
    description: "Calculate total and average value per asset type"

  - question: "Get total asset value by department"
    sql: |
      SELECT d.name as department,
        COUNT(a.id) as asset_count,
        SUM(a.purchase_cost) as total_value
      FROM departments d
      LEFT JOIN employees e ON d.id = e.department_id
      LEFT JOIN tr_assets a ON e.id = a.assigned_to AND a.status = 'approved'
      GROUP BY d.id, d.name
      ORDER BY total_value DESC NULLS LAST;
    category: analytics

  # Asset insert/update operations
  - question: "Insert a new asset request"
    sql: |
      INSERT INTO tr_assets (name, serial_number, purchase_date, purchase_cost, assigned_to, status, asset_type_id, notes)
      VALUES ($1, $2, $3::date, $4::decimal, $5::uuid, 'pending', $6::uuid, $7)
      RETURNING *;
    category: write
    description: "Create new asset request"

  - question: "Approve an asset request"
    sql: |
      UPDATE tr_assets 
      SET status = 'approved', updated_at = CURRENT_TIMESTAMP 
      WHERE id = $1::uuid AND status = 'pending'
      RETURNING *;
    category: write
    description: "Approve a pending asset request"

  - question: "Reject an asset request"
    sql: |
      UPDATE tr_assets 
      SET status = 'rejected', updated_at = CURRENT_TIMESTAMP 
      WHERE id = $1::uuid AND status = 'pending'
      RETURNING *;
    category: write

  - question: "Assign asset to employee"
    sql: |
      UPDATE tr_assets 
      SET assigned_to = $2::uuid, status = 'approved', updated_at = CURRENT_TIMESTAMP 
      WHERE id = $1::uuid
      RETURNING *;
    category: write
    description: "Assign an asset to an employee"

  - question: "Return asset"
    sql: |
      UPDATE tr_assets 
      SET assigned_to = NULL, status = 'Available', updated_at = CURRENT_TIMESTAMP 
      WHERE id = $1::uuid
      RETURNING *;
    category: write
    description: "Mark an asset as returned/unassigned"

  # User-specific asset queries (use $CURRENT_USER_ID placeholder)
  - question: "Show my assets"
    sql: |
      SELECT a.id, at.name as asset_type, a.name, a.serial_number,
             a.purchase_date, a.status, a.notes, a.created_at
      FROM tr_assets a
      LEFT JOIN asset_types at ON a.asset_type_id = at.id
      WHERE a.assigned_to = $CURRENT_USER_ID::uuid
      ORDER BY a.created_at DESC;
    category: user_specific
    description: "Get current user's assigned assets"

  - question: "Show my pending asset requests"
    sql: |
      SELECT a.id, at.name as asset_type, a.name, a.serial_number,
             a.status, a.notes, a.created_at
      FROM tr_assets a
      LEFT JOIN asset_types at ON a.asset_type_id = at.id
      WHERE a.assigned_to = $CURRENT_USER_ID::uuid
      AND a.status = 'pending'
      ORDER BY a.created_at DESC;
    category: user_specific
    description: "Get current user's pending asset requests"

  - question: "How many assets do I have?"
    sql: |
      SELECT COUNT(*) as my_asset_count 
      FROM tr_assets 
      WHERE assigned_to = $CURRENT_USER_ID::uuid 
      AND status = 'approved';
    category: user_specific

  # Manager-specific asset queries
  - question: "Show my team's assets"
    sql: |
      SELECT a.id, e.first_name, e.last_name, at.name as asset_type,
             a.name, a.serial_number, a.status
      FROM tr_assets a
      JOIN employees e ON a.assigned_to = e.id
      LEFT JOIN asset_types at ON a.asset_type_id = at.id
      WHERE e.manager_id = $CURRENT_USER_ID::uuid
      ORDER BY e.last_name, a.created_at DESC;
    category: manager
    description: "Get assets assigned to direct reports"

  - question: "Show pending asset requests I need to approve"
    sql: |
      SELECT a.id, e.first_name, e.last_name, at.name as asset_type,
             a.name, a.notes, a.created_at
      FROM tr_assets a
      JOIN employees e ON a.assigned_to = e.id
      LEFT JOIN asset_types at ON a.asset_type_id = at.id
      WHERE e.manager_id = $CURRENT_USER_ID::uuid
      AND a.status = 'pending'
      ORDER BY a.created_at DESC;
    category: manager
    description: "Get pending asset requests from direct reports"

  - question: "Get team asset value summary"
    sql: |
      SELECT 
        COUNT(a.id) as total_assets,
        SUM(a.purchase_cost) as total_value,
        COUNT(CASE WHEN a.status = 'pending' THEN 1 END) as pending_requests
      FROM tr_assets a
      JOIN employees e ON a.assigned_to = e.id
      WHERE e.manager_id = $CURRENT_USER_ID::uuid;
    category: manager
    description: "Summary of team's asset values and pending requests"

  # Asset type queries
  - question: "List all asset types"
    sql: |
      SELECT id, name, description 
      FROM asset_types 
      ORDER BY name;
    category: assets
    description: "Get all available asset types"

  - question: "Get assets by type"
    sql: |
      SELECT a.id, a.name, a.serial_number, a.status,
             e.first_name, e.last_name
      FROM tr_assets a
      LEFT JOIN employees e ON a.assigned_to = e.id
      WHERE a.asset_type_id = $1::uuid
      ORDER BY a.status, a.name;
    category: assets
    description: "Get all assets of a specific type"

  # Document counting and status queries
  - question: "How many pending documents are there?"
    sql: "SELECT COUNT(*) as pending_count FROM tr_documents WHERE status = 'pending';"
    category: documents
    description: "Count pending document approvals"

  - question: "How many documents were approved this month?"
    sql: |
      SELECT COUNT(*) as approved_count 
      FROM tr_documents 
      WHERE status = 'approved' 
      AND EXTRACT(MONTH FROM approved_at) = EXTRACT(MONTH FROM CURRENT_DATE)
      AND EXTRACT(YEAR FROM approved_at) = EXTRACT(YEAR FROM CURRENT_DATE);
    category: analytics

  - question: "Count documents by status"
    sql: "SELECT status, COUNT(*) as count FROM tr_documents GROUP BY status ORDER BY count DESC;"
    category: analytics

  - question: "Count documents by type"
    sql: |
      SELECT dt.name as document_type, COUNT(d.id) as count
      FROM document_types dt
      LEFT JOIN tr_documents d ON dt.id = d.type_id
      GROUP BY dt.id, dt.name
      ORDER BY count DESC;
    category: analytics

  # Document listing queries
  - question: "Show all pending document approvals"
    sql: |
      SELECT d.id, e.first_name, e.last_name, dt.name as document_type, 
             d.name, d.file_path, d.status, d.upload_date, d.notes
      FROM tr_documents d
      JOIN employees e ON d.employee_id = e.id
      LEFT JOIN document_types dt ON d.type_id = dt.id
      WHERE d.status = 'pending'
      ORDER BY d.upload_date DESC;
    category: documents
    description: "List all pending document approvals with employee details"

  - question: "Show approved documents this month"
    sql: |
      SELECT d.id, e.first_name, e.last_name, dt.name as document_type,
             d.name, d.approved_at, d.expiry_date
      FROM tr_documents d
      JOIN employees e ON d.employee_id = e.id
      LEFT JOIN document_types dt ON d.type_id = dt.id
      WHERE d.status = 'approved'
      AND EXTRACT(MONTH FROM d.approved_at) = EXTRACT(MONTH FROM CURRENT_DATE)
      ORDER BY d.approved_at DESC;
    category: documents

  - question: "Show documents for a specific employee"
    sql: |
      SELECT d.id, dt.name as document_type, d.name, d.file_path,
             d.upload_date, d.expiry_date, d.status, d.notes
      FROM tr_documents d
      LEFT JOIN document_types dt ON d.type_id = dt.id
      WHERE d.employee_id = $1::uuid
      ORDER BY d.upload_date DESC;
    category: documents
    description: "Get all documents for a specific employee by ID"

  - question: "Show documents expiring soon"
    sql: |
      SELECT d.id, e.first_name, e.last_name, dt.name as document_type,
             d.name, d.expiry_date,
             (d.expiry_date - CURRENT_DATE) as days_until_expiry
      FROM tr_documents d
      JOIN employees e ON d.employee_id = e.id
      LEFT JOIN document_types dt ON d.type_id = dt.id
      WHERE d.expiry_date IS NOT NULL
      AND d.expiry_date <= (CURRENT_DATE + INTERVAL '30 days')
      AND d.expiry_date >= CURRENT_DATE
      AND d.status = 'approved'
      ORDER BY d.expiry_date ASC;
    category: documents
    description: "List documents expiring in the next 30 days"

  - question: "Show expired documents"
    sql: |
      SELECT d.id, e.first_name, e.last_name, dt.name as document_type,
             d.name, d.expiry_date,
             (CURRENT_DATE - d.expiry_date) as days_expired
      FROM tr_documents d
      JOIN employees e ON d.employee_id = e.id
      LEFT JOIN document_types dt ON d.type_id = dt.id
      WHERE d.expiry_date IS NOT NULL
      AND d.expiry_date < CURRENT_DATE
      AND d.status = 'approved'
      ORDER BY d.expiry_date DESC;
    category: documents
    description: "List all expired documents"

  # Document insert/update operations
  - question: "Insert a new document"
    sql: |
      INSERT INTO tr_documents (employee_id, name, file_path, description, type_id, expiry_date, status, notes)
      VALUES ($1::uuid, $2, $3, $4, $5::uuid, $6::date, 'pending', $7)
      RETURNING *;
    category: write
    description: "Create new document record"

  - question: "Approve a document"
    sql: |
      UPDATE tr_documents 
      SET status = 'approved', approved_by = $2::uuid, approved_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP 
      WHERE id = $1::uuid AND status = 'pending'
      RETURNING *;
    category: write
    description: "Approve a pending document"

  - question: "Reject a document"
    sql: |
      UPDATE tr_documents 
      SET status = 'rejected', rejected_by = $2::uuid, rejected_at = CURRENT_TIMESTAMP, 
          rejection_reason = $3, updated_at = CURRENT_TIMESTAMP 
      WHERE id = $1::uuid AND status = 'pending'
      RETURNING *;
    category: write
    description: "Reject a pending document with reason"

  - question: "Update document expiry date"
    sql: |
      UPDATE tr_documents 
      SET expiry_date = $2::date, updated_at = CURRENT_TIMESTAMP 
      WHERE id = $1::uuid
      RETURNING *;
    category: write
    description: "Update document expiry date"

  # User-specific document queries (use $CURRENT_USER_ID placeholder)
  - question: "Show my documents"
    sql: |
      SELECT d.id, dt.name as document_type, d.name, d.file_path,
             d.upload_date, d.expiry_date, d.status, d.notes
      FROM tr_documents d
      LEFT JOIN document_types dt ON d.type_id = dt.id
      WHERE d.employee_id = $CURRENT_USER_ID::uuid
      ORDER BY d.upload_date DESC;
    category: user_specific
    description: "Get current user's documents"

  - question: "Show my pending documents"
    sql: |
      SELECT d.id, dt.name as document_type, d.name, d.file_path,
             d.status, d.notes, d.upload_date
      FROM tr_documents d
      LEFT JOIN document_types dt ON d.type_id = dt.id
      WHERE d.employee_id = $CURRENT_USER_ID::uuid
      AND d.status = 'pending'
      ORDER BY d.upload_date DESC;
    category: user_specific
    description: "Get current user's pending documents"

  - question: "Show my expiring documents"
    sql: |
      SELECT d.id, dt.name as document_type, d.name, d.expiry_date,
             (d.expiry_date - CURRENT_DATE) as days_until_expiry
      FROM tr_documents d
      LEFT JOIN document_types dt ON d.type_id = dt.id
      WHERE d.employee_id = $CURRENT_USER_ID::uuid
      AND d.expiry_date IS NOT NULL
      AND d.expiry_date <= (CURRENT_DATE + INTERVAL '30 days')
      AND d.expiry_date >= CURRENT_DATE
      AND d.status = 'approved'
      ORDER BY d.expiry_date ASC;
    category: user_specific
    description: "Get current user's documents expiring soon"

  - question: "How many documents do I have?"
    sql: |
      SELECT COUNT(*) as my_document_count 
      FROM tr_documents 
      WHERE employee_id = $CURRENT_USER_ID::uuid;
    category: user_specific

  # Manager-specific document queries
  - question: "Show my team's documents"
    sql: |
      SELECT d.id, e.first_name, e.last_name, dt.name as document_type,
             d.name, d.expiry_date, d.status
      FROM tr_documents d
      JOIN employees e ON d.employee_id = e.id
      LEFT JOIN document_types dt ON d.type_id = dt.id
      WHERE e.manager_id = $CURRENT_USER_ID::uuid
      ORDER BY e.last_name, d.upload_date DESC;
    category: manager
    description: "Get documents for direct reports"

  - question: "Show pending documents I need to approve"
    sql: |
      SELECT d.id, e.first_name, e.last_name, dt.name as document_type,
             d.name, d.notes, d.upload_date
      FROM tr_documents d
      JOIN employees e ON d.employee_id = e.id
      LEFT JOIN document_types dt ON d.type_id = dt.id
      WHERE e.manager_id = $CURRENT_USER_ID::uuid
      AND d.status = 'pending'
      ORDER BY d.upload_date DESC;
    category: manager
    description: "Get pending document approvals from direct reports"

  - question: "Show my team's expiring documents"
    sql: |
      SELECT d.id, e.first_name, e.last_name, dt.name as document_type,
             d.name, d.expiry_date,
             (d.expiry_date - CURRENT_DATE) as days_until_expiry
      FROM tr_documents d
      JOIN employees e ON d.employee_id = e.id
      LEFT JOIN document_types dt ON d.type_id = dt.id
      WHERE e.manager_id = $CURRENT_USER_ID::uuid
      AND d.expiry_date IS NOT NULL
      AND d.expiry_date <= (CURRENT_DATE + INTERVAL '30 days')
      AND d.expiry_date >= CURRENT_DATE
      AND d.status = 'approved'
      ORDER BY d.expiry_date ASC;
    category: manager
    description: "Get team documents expiring in next 30 days"

  - question: "Show documents I have approved"
    sql: |
      SELECT d.id, e.first_name, e.last_name, dt.name as document_type,
             d.name, d.approved_at
      FROM tr_documents d
      JOIN employees e ON d.employee_id = e.id
      LEFT JOIN document_types dt ON d.type_id = dt.id
      WHERE d.approved_by = $CURRENT_USER_ID::uuid
      ORDER BY d.approved_at DESC;
    category: manager

  # Document analytics
  - question: "Get document summary by department"
    sql: |
      SELECT dep.name as department,
        COUNT(CASE WHEN d.status = 'pending' THEN 1 END) as pending,
        COUNT(CASE WHEN d.status = 'approved' THEN 1 END) as approved,
        COUNT(CASE WHEN d.status = 'rejected' THEN 1 END) as rejected,
        COUNT(CASE WHEN d.expiry_date < CURRENT_DATE THEN 1 END) as expired
      FROM departments dep
      LEFT JOIN employees e ON dep.id = e.department_id
      LEFT JOIN tr_documents d ON e.id = d.employee_id
      GROUP BY dep.id, dep.name
      ORDER BY dep.name;
    category: analytics
    description: "Document statistics by department"

  - question: "Get expiring documents count by department"
    sql: |
      SELECT dep.name as department,
        COUNT(d.id) as expiring_documents
      FROM departments dep
      LEFT JOIN employees e ON dep.id = e.department_id
      LEFT JOIN tr_documents d ON e.id = d.employee_id
        AND d.expiry_date IS NOT NULL
        AND d.expiry_date <= (CURRENT_DATE + INTERVAL '30 days')
        AND d.expiry_date >= CURRENT_DATE
        AND d.status = 'approved'
      GROUP BY dep.id, dep.name
      ORDER BY expiring_documents DESC;
    category: analytics

  # Document type queries
  - question: "List all document types"
    sql: |
      SELECT id, name, description 
      FROM document_types 
      ORDER BY name;
    category: documents
    description: "Get all available document types"

  - question: "Get documents by type"
    sql: |
      SELECT d.id, d.name, d.expiry_date, d.status,
             e.first_name, e.last_name
      FROM tr_documents d
      JOIN employees e ON d.employee_id = e.id
      WHERE d.type_id = $1::uuid
      ORDER BY d.status, d.upload_date DESC;
    category: documents
    description: "Get all documents of a specific type"

  - question: "Get document compliance report"
    sql: |
      SELECT 
        dt.name as document_type,
        COUNT(d.id) as total_documents,
        COUNT(CASE WHEN d.status = 'approved' AND (d.expiry_date IS NULL OR d.expiry_date >= CURRENT_DATE) THEN 1 END) as valid_documents,
        COUNT(CASE WHEN d.expiry_date < CURRENT_DATE THEN 1 END) as expired_documents,
        COUNT(CASE WHEN d.status = 'pending' THEN 1 END) as pending_documents
      FROM document_types dt
      LEFT JOIN tr_documents d ON dt.id = d.type_id
      GROUP BY dt.id, dt.name
      ORDER BY dt.name;
    category: analytics
    description: "Document compliance summary by type"

documentation:
  - topic: "CRITICAL TABLE NAMING RULES"
    content: |
      ⚠️ CRITICAL - READ THIS FIRST ⚠️
      
      The following table names DO NOT EXIST and must NEVER be used:
      - ❌ leave_requests (WRONG) → ✅ Use 'tr_leaves' instead
      - ❌ leaves (WRONG) → ✅ Use 'tr_leaves' instead  
      - ❌ leave_applications (WRONG) → ✅ Use 'tr_leaves' instead
      - ❌ time_off (WRONG) → ✅ Use 'tr_leaves' instead
      - ❌ pto_requests (WRONG) → ✅ Use 'tr_leaves' instead
      - ❌ assets (WRONG) → ✅ Use 'tr_assets' instead
      - ❌ asset_requests (WRONG) → ✅ Use 'tr_assets' instead
      - ❌ equipment (WRONG) → ✅ Use 'tr_assets' instead
      - ❌ documents (WRONG) → ✅ Use 'tr_documents' instead
      - ❌ employee_documents (WRONG) → ✅ Use 'tr_documents' instead
      - ❌ files (WRONG) → ✅ Use 'tr_documents' instead
      
      The 'tr_' prefix indicates a TRANSACTION table.
      
      CORRECT TABLE NAMES:
      - tr_leaves: Leave requests and approvals (THE ONLY leave table)
      - tr_assets: Asset assignments and tracking (THE ONLY asset table)
      - tr_documents: Employee document management (THE ONLY document table)
      - asset_types: Asset type/category definitions
      - document_types: Document type/category definitions
      - employees: Employee master data
      - roles: Role definitions
      - leave_types: Types of leaves (sick, vacation, etc.)
      - departments: Organization departments
      - permissions: Permission definitions
      - tr_role_permissions: Role-to-permission mappings
      - employees: Employee master data
      - roles: Role definitions
      - leave_types: Types of leaves (sick, vacation, etc.)
      - departments: Organization departments
      - permissions: Permission definitions
      - tr_role_permissions: Role-to-permission mappings

  - topic: "Schema Overview"
    content: |
      HRMS Database Schema Overview:
      
      1. CRITICAL: Leave requests are stored in 'tr_leaves' table (NOT 'leaves')
         - The 'tr_' prefix indicates a transaction/transactional table
      
      2. Primary Tables:
         - tr_leaves: Leave requests and approvals
         - employees: Employee master data (UUID primary key)
         - roles: Role definitions with access levels
         - leave_types: Leave type configuration
         - departments: Organization structure
      
      3. Key Relationships:
         - tr_leaves.employee_id → employees.id
         - tr_leaves.leave_type_id → leave_types.id
         - tr_leaves.approved_by → employees.id
         - employees.department_id → departments.id
         - employees.role_id → roles.id
         - employees.manager_id → employees.id (self-reference)

  - topic: "UUID Handling"
    content: |
      Employee IDs are UUID type. When querying or inserting:
      - Use ::uuid cast: WHERE employee_id = $1::uuid
      - For INSERT: VALUES ($1::uuid, ...)
      - Never use integer operations on UUID columns

  - topic: "Status Values"
    content: |
      Leave status values:
      - 'pending': Awaiting approval
      - 'approved': Approved by manager
      - 'rejected': Rejected by manager
      - 'cancelled': Cancelled by employee
      
      Employee status values:
      - 'active': Currently employed
      - 'inactive': No longer employed

  - topic: "Best Practices"
    content: |
      SQL Generation Best Practices:
      1. Always use tr_leaves (not leaves) for leave queries
      2. Filter by status = 'active' for employee queries
      3. Use RETURNING * for INSERT/UPDATE to get affected rows
      4. Calculate days as (end_date - start_date + 1)
      5. Use LEFT JOIN for optional relationships
      6. Use ILIKE for case-insensitive text search
      7. Use EXTRACT(YEAR/MONTH FROM date) for date filtering

  - topic: "User-Aware Queries"
    content: |
      Automatic User Context Filtering:
      
      When generating SQL, consider the current user's context for personalized queries:
      
      1. Personal Queries (use employee_id filter):
         - "my leaves", "my pending requests" → WHERE employee_id = $CURRENT_USER_ID
         - Always filter by the authenticated user's employee_id
      
      2. Manager Queries (use manager_id filter):
         - "leaves I need to approve", "my team's leaves" → WHERE e.manager_id = $CURRENT_USER_ID
         - "leaves I approved" → WHERE approved_by = $CURRENT_USER_ID
         - Managers can see their direct reports' leaves
      
      3. Role-Based Access:
         - Regular employees: Only see their own leaves
         - Managers: See own leaves + team members' leaves
         - HR/Admin: See all leaves in department or organization
      
      4. Context Variables:
         - $CURRENT_USER_ID: The authenticated user's employee UUID
         - Use this placeholder in WHERE clauses for user-specific filtering
      
      5. Query Patterns:
         - "Show my X" → Filter by employee_id = $CURRENT_USER_ID
         - "Show X I need to approve" → Filter by manager_id = $CURRENT_USER_ID AND status = 'pending'
         - "Show my team's X" → Filter by manager_id = $CURRENT_USER_ID
         - "Show X I approved" → Filter by approved_by = $CURRENT_USER_ID

relationships:
  - from_table: tr_leaves
    to_table: employees
    from_column: employee_id
    to_column: id
    relationship_type: many-to-one
    description: "Each leave request belongs to one employee"

  - from_table: tr_leaves
    to_table: leave_types
    from_column: leave_type_id
    to_column: id
    relationship_type: many-to-one
    description: "Each leave request has one leave type"

  - from_table: tr_leaves
    to_table: employees
    from_column: approved_by
    to_column: id
    relationship_type: many-to-one
    description: "Each leave can be approved/rejected by one manager"

  - from_table: employees
    to_table: departments
    from_column: department_id
    to_column: id
    relationship_type: many-to-one
    description: "Each employee belongs to one department"

  - from_table: employees
    to_table: roles
    from_column: role_id
    to_column: id
    relationship_type: many-to-one
    description: "Each employee has one role"

  - from_table: employees
    to_table: employees
    from_column: manager_id
    to_column: id
    relationship_type: many-to-one
    description: "Each employee can have one manager (self-reference)"

  - from_table: tr_role_permissions
    to_table: roles
    from_column: role_id
    to_column: id
    relationship_type: many-to-one
    description: "Each role-permission mapping belongs to one role"

  - from_table: tr_role_permissions
    to_table: permissions
    from_column: permission_id
    to_column: id
    relationship_type: many-to-one
    description: "Each role-permission mapping references one permission"

  - from_table: tr_assets
    to_table: employees
    from_column: assigned_to
    to_column: id
    relationship_type: many-to-one
    description: "Each asset can be assigned to one employee"

  - from_table: tr_assets
    to_table: asset_types
    from_column: asset_type_id
    to_column: id
    relationship_type: many-to-one
    description: "Each asset belongs to one asset type"

  - from_table: tr_documents
    to_table: employees
    from_column: employee_id
    to_column: id
    relationship_type: many-to-one
    description: "Each document belongs to one employee"

  - from_table: tr_documents
    to_table: document_types
    from_column: type_id
    to_column: id
    relationship_type: many-to-one
    description: "Each document has one document type"

  - from_table: tr_documents
    to_table: employees
    from_column: approved_by
    to_column: id
    relationship_type: many-to-one
    description: "Each document can be approved by one employee"

  - from_table: tr_documents
    to_table: employees
    from_column: rejected_by
    to_column: id
    relationship_type: many-to-one
    description: "Each document can be rejected by one employee"
